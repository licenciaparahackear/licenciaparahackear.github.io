<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Licencia para Hackear</title><link>https://licenciaparahackear.github.io/</link><description>Seguridad informática, computación y software libre</description><atom:link href="https://licenciaparahackear.github.io/rss.xml" rel="self" type="application/rss+xml"></atom:link><language>es</language><copyright>Contents © 2021 &lt;a href="mailto:pub@matiaslang.me"&gt;Matías Lang&lt;/a&gt; 
&lt;a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"&gt;&lt;img alt="Licencia Creative Commons" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /&gt;&lt;/a&gt;&lt;br /&gt;Esta obra está bajo una &lt;a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"&gt;Licencia Creative Commons Atribución-CompartirIgual 4.0 Internacional&lt;/a&gt;.
</copyright><lastBuildDate>Mon, 28 Jun 2021 20:13:43 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Filtrando mis contactos del celular con AWK</title><link>https://licenciaparahackear.github.io/posts/filtrando-mis-contactos-del-celular-con-awk/</link><dc:creator>Matías Lang</dc:creator><description>&lt;figure&gt;&lt;img src="https://licenciaparahackear.github.io/images/og-awk.png"&gt;&lt;/figure&gt; &lt;div&gt;&lt;p&gt;Hace unas semanas cambié mi celular con Android. Una de las cosas que tuve que
hacer fue importar los contactos del celu viejo al nuevo. Como no uso soluciones
de almacenamiento en la nube por cuestiones de privacidad, la importación la
hice de forma manual, usando ficheros &lt;a href="https://es.wikipedia.org/wiki/VCard"&gt;vCard (con extensión .vcf)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;En su momento, cuando todavía usaba Android con los servicios de Google, a la
aplicación de Gmail se le ocurrió crear un contacto para cada usuario con quien
haya intercambiado algún correo electrónico. Esto me creó un montón de contactos
que no aportan nada en mi celular. Contactos a quienes les escribí por única
vez, sin intención de hacerlo nuevamente. De quienes solamente conozco su
dirección de correo electrónico y no su celular. &lt;/p&gt;
&lt;p&gt;Como estaba cambiando el celu, me pareció que sería una buena ocasión para
borrar todos estos contactos innecesarios. Para esto necesitaría:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exportar todos mis contactos del celular viejo a un &lt;a href="https://es.wikipedia.org/wiki/VCard"&gt;fichero .vcf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Encontrar o armar una herramienta que borre todos aquellos contactos que no
  tengan número de teléfono&lt;/li&gt;
&lt;li&gt;Grabar la salida en un nuevo fichero .vcf, listo para ser importado en el
  celular nuevo&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para escribir una herramienta que filtre contactos tendría que ser capaz de
parsear un fichero .vcf. Normalmente hubiese usado Python para resolver el
problema. Podría haber utilizado una &lt;a href="https://gitlab.com/victor-engmark/vcard"&gt;librería externa&lt;/a&gt; y confiar
en que no tenga bugs ni vulnerabilidades. O podría haber creado mi propia
librería para manejo de .vcf/vCard, propiamente testeada y documentada. Sin
embargo, ambas opciones parecían demasiado complicadas para un programa que
pretendo correr una única vez. Tiene que haber una solución más simple.&lt;/p&gt;
&lt;p&gt;Un fichero vcf tiene el siguiente formato:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="n"&gt;BEGIN&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;VCARD&lt;/span&gt;
&lt;span class="n"&gt;VERSION&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;2.1&lt;/span&gt;
&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Nombre&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="n"&gt;Apellido&lt;/span&gt;&lt;span class="o"&gt;;;;&lt;/span&gt;
&lt;span class="n"&gt;FN&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Nombre&lt;/span&gt; &lt;span class="n"&gt;Visible&lt;/span&gt;
&lt;span class="n"&gt;TEL&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="n"&gt;CELL&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;123&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;456&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;789&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;VCARD&lt;/span&gt;
&lt;span class="n"&gt;BEGIN&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;VCARD&lt;/span&gt;
&lt;span class="n"&gt;VERSION&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;2.1&lt;/span&gt;
&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Otro&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="n"&gt;Contacto&lt;/span&gt;&lt;span class="o"&gt;;;;&lt;/span&gt;
&lt;span class="n"&gt;FN&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;Otro&lt;/span&gt; &lt;span class="n"&gt;contacto&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;Gmail&lt;/span&gt;
&lt;span class="n"&gt;EMAIL&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;&lt;span class="n"&gt;PREF&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;usuario&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;gmail&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;com&lt;/span&gt;
&lt;span class="n"&gt;END&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;VCARD&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Como se ve, los detalles de cada contacto se encuentran entre las líneas
&lt;code&gt;BEGIN:VCARD&lt;/code&gt; y &lt;code&gt;END:VCARD&lt;/code&gt;. El formato en sí no parece nada complicado, ya que
es texto plano delimitado por líneas.&lt;/p&gt;
&lt;p&gt;Teniendo en cuenta de que quería parsear un fichero en un formato simple y
hacerlo una única vez, me decidí por usar &lt;a href="https://es.wikipedia.org/wiki/AWK"&gt;AWK&lt;/a&gt; en vez del tradicional
Python. El lenguaje AWK es bastante chico y por esto se puede aprender en pocas
horas. Con leer &lt;a href="https://es.wikipedia.org/wiki/AWK"&gt;su página en Wikipedia&lt;/a&gt; ya se puede entender bastante su
funcionamiento.&lt;/p&gt;
&lt;p&gt;Después de repasar un poco, me armé un programa de awk corto pero efectivo:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="c1"&gt;# lineas va a guardar las líneas del contacto a procesar en un array.&lt;/span&gt;
&lt;span class="c1"&gt;# n es la longitud del array, que se incrementa en cada iteración.&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;lineas&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;$&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;# Esto sería similar a un append en Python&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="sr"&gt;/^TEL;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;# el contacto siendo procesado tiene un teléfono, así que quiero que se muestre&lt;/span&gt;
    &lt;span class="nx"&gt;tiene_telefono&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="sr"&gt;/^END:VCARD/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;# llegué al final del contacto, tengo que decidir si mostrarlo o no&lt;/span&gt;

    &lt;span class="c1"&gt;# si tenía un teléfono, mostrar todas las líneas que tengo guardadas&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;tiene_telefono&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="kr"&gt;print&lt;/span&gt; &lt;span class="nx"&gt;lineas&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="c1"&gt;# en la próxima iteración voy a arrancar con nuevo contacto, así que&lt;/span&gt;
    &lt;span class="c1"&gt;# reinicio el estado del programa.&lt;/span&gt;
    &lt;span class="nx"&gt;tiene_telefono&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="nx"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="c1"&gt;# Esto simula varias el array&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Después ejecuté el programa corriendo &lt;code&gt;awk -f miprograma.awk
&amp;lt;contactos-sin-filtrar.vcf &amp;gt;contactos-filtrados.vcf&lt;/code&gt;. Eso me generó un nuevo
.vcf con los contactos ya filtrados, listo para importar en mi celular.&lt;/p&gt;
&lt;p&gt;Con solamente 13 líneas de código (sin contar comentarios ni líneas vacías),
logré armar un programa que solucionó mi problema a la perfección. No me
compliqué instalando librerías externas, creando jerarquías de clases
inentendibles, ni haciendo parsers complejos de algún formato.&lt;/p&gt;
&lt;p&gt;Así parece que con un lenguaje con más de 40 años de antigüedad me sentí más
cómodo que con Python, mi lenguaje de preferencia. Esto se debe a que AWK es un
lenuaje especializado en manejo de ficheros de texto y programas de un solo uso.
Quizás el código no sea tan mantenible, pero no me importa si se que no lo voy a
volver a correr. Necesitaba una solución rapida, y AWK cumplió a la perfección.&lt;/p&gt;
&lt;p&gt;Espero con este post haber explicado la esencia del lenguaje AWK. Me parece que
es una herramienta fundamental para cualquier persona que se dedique a programar
o administrar sistemas UNIX-style. El lenguaje se puede aprender en pocas horas,
y es capaz de mejorar muchísimo nuestra productividad.&lt;/p&gt;
&lt;p&gt;Algunos recursos que me sirvieron para aprender AWK (están en inglés):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.jpalardy.com/posts/why-learn-awk/"&gt;Why Learn AWK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Guía rapida de AWK,
  &lt;a href="https://jemma.dev/blog/awk-part-1"&gt;parte 1&lt;/a&gt; y
  &lt;a href="https://jemma.dev/blog/awk-part-2"&gt;parte 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=IfhMUed9RSE"&gt;"An AWK love story"&lt;/a&gt;, charla que
  explica la escencia del lenguaje&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;También existe &lt;a href="https://www.goodreads.com/book/show/703101.The_AWK_Programming_Language"&gt;un libro&lt;/a&gt; sobre el lenguaje escrito por sus autores. No
lo puedo recomendar porque todavía lo leí, pero en caso de que los recursos
anteriores te dejen con ganas de más, este libro seguro es el siguiente paso.&lt;/p&gt;
&lt;p&gt;Saludos!&lt;/p&gt;&lt;/div&gt;</description><category>android</category><category>awk</category><category>unix</category><guid>https://licenciaparahackear.github.io/posts/filtrando-mis-contactos-del-celular-con-awk/</guid><pubDate>Sat, 26 Jun 2021 22:38:49 GMT</pubDate></item><item><title>Ekoparty CTF: Stegano Writeup</title><link>https://licenciaparahackear.github.io/posts/ekoparty-ctf-stegano-writeup/</link><dc:creator>Matías Lang</dc:creator><description>&lt;div&gt;&lt;p&gt;Hace unos días fue la Ekoparty Online 2020. Esta vez la conferencia fue online,
así que opté por participar activamente en el CTF en vez de asistir a las
charlas. Muchos retos me resultaron bastante desafiantes, entre ellos
&lt;strong&gt;Stegano&lt;/strong&gt;, uno de los últimos que pudimos resolver junto a &lt;a href="https://twitter.com/EzequielTBH/"&gt;EzequielTBH&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Para este reto se nos entregaba una &lt;a href="https://licenciaparahackear.github.io/stegano.bmp"&gt;imagen en formato BMP&lt;/a&gt;, así
que nos imaginamos que la flag iba a estar escondida ahí. Subiendo la imagen al
buscador Google Images y agregando la palabra clave &lt;strong&gt;steganography&lt;/strong&gt;, nos
encontramos con un &lt;a href="https://securitynews.sonicwall.com/xmlpost/loki-bot-started-using-image-steganography-and-multi-layered-protection/"&gt;blogpost hablando de la esteganografía usada por
Loki-Bot&lt;/a&gt;. Sabiendo que la temática del CTF era el malware, nos
imaginamos que el problema venía por ahí.&lt;/p&gt;
&lt;p&gt;Leyendo el blogpost vimos que en una parte se describía, mostrando código C, el
proceso por el cual se descifra un mensaje aplicándole un XOR con la clave
&lt;code&gt;@y_%_M_ew@&lt;/code&gt; y con la variable de un byte &lt;code&gt;dwKeysize&lt;/code&gt;, que representa
la longitud de esta clave (en este caso, 10 o 0xA):&lt;/p&gt;
&lt;p&gt;&lt;img alt="Descifrado de mensajes usando XOR" src="https://licenciaparahackear.github.io/images/stegano/DecryptionLogic.png"&gt;&lt;/p&gt;
&lt;p&gt;También se mencionaba un proceso por el cual se obtiene el mensaje escondido
dentro del fichero BMP:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Proceso de obtención del mensaje oculto en el BMP" src="https://licenciaparahackear.github.io/images/stegano/Steganography.jpg"&gt;&lt;/p&gt;
&lt;!-- También se mencionaba un proceso de descifrado de mensajes, que consistíá en un --&gt;

&lt;!-- simple XOR del mensaje con la clave `@y_%_M_ew@` y con un byte representando la --&gt;

&lt;!-- longitud de la clave (10 bytes, o 0xA): --&gt;

&lt;p&gt;Si bien el proceso de descifrado usando XOR se entendió bastante bien, este
código para obtener el mensaje en el BMP era algo confuso y tenía bastantes
constantes que no entendimos de dónde se sacaron. Hacer un programa que obtenga
el mensaje de forma perfecta nos hubiese llevado bastante tiempo, y faltaba
poco para que el CTF termine. Sin embargo, la perfección no es necesaria para
resolver un reto. Lo único que necesitábamos era obtener la flag, que tiene el
formato &lt;code&gt;EKO{...}&lt;/code&gt;. No nos importa que la información descifrada conserve su
integridad, sino que nos podemos permitir que tenga algunos bytes que son
basura, siempre y cuando nos muestre la flag. Teniendo en cuenta esto, usamos
una versión simplificada del algoritmo de descifrado. No es para nada perfecta,
pero cumplió su propósito.&lt;/p&gt;
&lt;p&gt;Si volvemos al código en C que lee el fichero BMP podemos notar algunas cosas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Se calcula desde qué byte empezar a descifrar teniendo en cuenta el header
  del fichero BMP, el ancho y alto de la imagen&lt;/li&gt;
&lt;li&gt;Mucha de la lógica en el código consiste en detectar cuándo se llegó al final
  de una fila para así pasar a la fila siguiente, arrancando desde la primer
  columna. Los bloques &lt;em&gt;if&lt;/em&gt; dentro del código se encargan de hacer esto.&lt;/li&gt;
&lt;li&gt;En cada iteración del &lt;em&gt;for&lt;/em&gt;, se leen dos bytes del fichero (esto se puede ver
  en el código resaltado). El &lt;code&gt;&amp;amp; 0x0F&lt;/code&gt; se
  queda solamente con los últimos 4 bits de cada byte, ignorando los bits más
  significativos.&lt;/li&gt;
&lt;li&gt;Se juntan los 4 últimos bits del segundo byte leído con los 4 últimos del primero,
  para así escribir un byte por cada dos leídos&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Teniendo en cuenta que el tamaño de la flag es de unos pocos bytes y que el
ancho del BMP es de 801 píxeles, es poco probable que la flag esté distribuida
en dos filas distintas, así que todo el código relacionado a los límites de la
imagen se puede ignorar. Además, como no nos importa descifrar información
corrupta, siempre y cuando se encuentre la flag, tampoco es necesario calcular
desde dónde empezar a descifrar: para simplificar el código, podemos descifrar
todo desde el inicio hasta el final de la imagen.&lt;/p&gt;
&lt;p&gt;Sabiendo esto, es posible tener una solución más simple al código en C
descripto en el blogpost. Solamente habría que ir leyendo el fichero BMP de a
dos bytes, juntarlos en un único byte usando operaciones a nivel de bits, y
aplicarle un XOR con la clave &lt;code&gt;@y_%_M_ew@&lt;/code&gt;. Esto sería bastante sencillo,
aunque es necesario tener en cuenta algunas cosas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Como se lee de a dos bytes, no es lo mismo arrancar en un byte par que en
  uno impar. Una de las dos formas va a producir información incorrecta.&lt;/li&gt;
&lt;li&gt;El cifrado XOR depende de la posición en la que se arranca. Si arrancamos
  a descifrar desde una posición incorrecta, la clave puede quedar "desfasada"
  y descifrar cualquier cosa&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Como solución a estos problemas, usamos un método sucio pero eficiente:
probemos todas las combinaciones hasta dar con el resultado. Podemos leer
primero desde un byte par, después desde uno impar. O podemos probar con todas
las posibles rotaciones de la clave (como es de 10 bytes, hay 10 posibles
rotaciones).&lt;/p&gt;
&lt;p&gt;Finalmente, armamos el siguiente script de Python que lee la imagen y prueba
descifrarla usando las combinaciones descriptas anteriormente:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;

&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'stegano.bmp'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'rb'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;bmp_contents&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'stegano-output'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;'wb'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;try_decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;encoded&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;first_byte&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;second_byte&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="n"&gt;encoded&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(((&lt;/span&gt;&lt;span class="n"&gt;second_byte&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0x0f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;first_byte&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0x0f&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;decoded&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="mh"&gt;0xA&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;encoded&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;decoded&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;


&lt;span class="n"&gt;ORIGINAL_KEY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sa"&gt;b&lt;/span&gt;&lt;span class="s1"&gt;'@y_%_M_ew@'&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;possible_keys&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="c1"&gt;# rotate the original key&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ORIGINAL_KEY&lt;/span&gt;&lt;span class="p"&gt;)):&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;ORIGINAL_KEY&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;ORIGINAL_KEY&lt;/span&gt;&lt;span class="p"&gt;[:&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;possible_keys&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;try_decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bmp_contents&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;try_decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bmp_contents&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:])&lt;/span&gt;  &lt;span class="c1"&gt;# arrancar desde un byte impar&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Una vez que lo ejecutamos y abrimos el fichero &lt;code&gt;stegano-output&lt;/code&gt; con un editor
hexadecimal, encontramos la flag que resultó siendo
&lt;code&gt;EKO{n0m0r3m4lw4r3_and_m04r_st3g4n00000000}&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Flag en el fichero stegano-output" src="https://licenciaparahackear.github.io/images/stegano/flag.png"&gt;&lt;/p&gt;
&lt;p&gt;Así pudimos resolver este reto de esteganografía. Si bien este tipo de retos no
suelen ser mis preferidos, en este caso lo disfruté bastante. No es el clásico
ejemplo de una imagen pasada por el &lt;a href="http://steghide.sourceforge.net/"&gt;steghide&lt;/a&gt; o herramientas
similares, sino que requería entender el código que usaba un malware para
ocultar la información.&lt;/p&gt;
&lt;p&gt;Para concluir el post, quiero destacar la importancia de reconocer que el
objetivo de un reto es obtener la flag. Teniendo en cuenta esto, es posible
obviar ciertos detalles que no aportan mucho y son bastante tediosos, como fue
en este caso la lógica de decidir qué bytes usar para descifrar. Si no hubiese
tenido esto en cuenta, quizás no hubiese podido resolver el reto a tiempo.&lt;/p&gt;
&lt;p&gt;Espero con este post haber descripto no solo la solución al reto, sino también
el proceso que seguimos para solucionarlo. Pronto publicaré las soluciones a
algún otro reto que me haya gustado.&lt;/p&gt;
&lt;p&gt;Saludos!&lt;/p&gt;&lt;/div&gt;</description><category>ctf</category><category>steganography</category><category>writeup</category><guid>https://licenciaparahackear.github.io/posts/ekoparty-ctf-stegano-writeup/</guid><pubDate>Mon, 28 Sep 2020 22:33:11 GMT</pubDate></item><item><title>Invitación a nerdear.la</title><link>https://licenciaparahackear.github.io/posts/invitacion-a-nerdearla/</link><dc:creator>Matías Lang</dc:creator><description>&lt;div&gt;&lt;p&gt;El 17, 18 y 19 de octubre de este año se llevará a cabo &lt;a href="https://nerdear.la"&gt;Nerdear.la&lt;/a&gt;: una
conferencia sobre devops, desarrollo y temática nerd en general. Se trata de la
sexta edición del evento, y es la primera vez que se hace en Ciudad Cultural
Konex. La entrada es 100% gratis, al igual que en años anteriores.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Nerdearla 2018" src="https://licenciaparahackear.github.io/images/nerdearla2018.jpg"&gt;&lt;/p&gt;
&lt;p&gt;Este año, la conferencia contará con un &lt;a href="https://nerdear.la/agenda/"&gt;excelente nivel de charlas&lt;/a&gt;
que nada tiene que envidiarle a otros eventos, locales o internacionales. El
jueves a las 16:35 yo voy a estar dando una charla sobre entornos reproducibles
y cómo utilizar &lt;a href="https://nixos.org/nix/"&gt;Nix&lt;/a&gt; como alternativa a Dockerfiles. Acto seguido,
&lt;a href="https://twitter.com/jpdborgna"&gt;GiBA&lt;/a&gt; va a hablar sobre una herramienta de logging bastante prometedora
que hicieron en Facebook.&lt;/p&gt;
&lt;p&gt;Otras charlas que me interesaron:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Making Illegal States Unrepresentable (in JavaScript): por el título, supongo
  que va a hablar un poco de &lt;a href="https://elm-lang.org/"&gt;Elm&lt;/a&gt;, uno de mis lenguajes de programación
  preferidos, y mostrar como se pueden adaptar ciertas cosas del lenguaje a
  Javascript.&lt;/li&gt;
&lt;li&gt;Diagnosing bad TDD habits with Dr.TDD: una charla sobre TDD y &lt;a href="https://es.wikipedia.org/wiki/Smalltalk"&gt;Smalltalk&lt;/a&gt;,
  que encima tiene &lt;a href="https://vimeo.com/354461588"&gt;un video en su descripción&lt;/a&gt;! Definitivamente no me la pienso
  perder.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://es.wikipedia.org/wiki/Donald_Knuth"&gt;Donald Knuth&lt;/a&gt;, TeX y la curva del dragón: hablará de TeX, el
  predecesor de LaTeX. Si bien no es un sistema que me guste mucho, tiene una
  historia muy interesante, en especial por tratarse de uno de los proyectos más
  importantes de &lt;a href="https://es.wikipedia.org/wiki/Donald_Knuth"&gt;Donald Knuth&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Standup Matemático: por si creían que para llamarse "nerdear.la" le faltaban cosas nerd.&lt;/li&gt;
&lt;li&gt;1969 - 2019: 50 years of UNIX and the landing on the Moon: charla de cierre dada por el
  conocido &lt;a href="https://twitter.com/maddoghall"&gt;Jon «maddog» Hall&lt;/a&gt;. No pude asistir a la charla que dio la última vez
  que estuvo en Argentina, así que esta es mi oportunidad de hacerlo!&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;También estarán dando un taller de introducción a Bash dictado por las chicas
de &lt;a href="https://twitter.com/linuxchixar"&gt;LinuxChix Argentina&lt;/a&gt; que vengo recomendando hace unos días a
gente con poca experiencia con el uso de la terminal en GNU/Linux. Es de cupo
limitado así que &lt;a href="https://docs.google.com/forms/d/e/1FAIpQLSdIz_3gsHsSL4U58BysEQy5TH2zRWgYNFV0okZplDaJa-u45A/viewform"&gt;hay que inscribirse primero&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Y para quienes tengan que trabajar durante los días de la conferencia, también
contará con un espacio de coworking que, al menos hasta el año pasado, siempre
contó con una buena conexión a internet.&lt;/p&gt;
&lt;p&gt;Para más información sobre el evento, puden visitar su sitio
&lt;a href="https://nerdear.la/"&gt;https://nerdear.la/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Saludos!&lt;/p&gt;
&lt;h4&gt;Apéndice&lt;/h4&gt;
&lt;p&gt;No encontré en la página la descripción completa de mi charla, así que la dejo
por acá para quien esté interesado/a:&lt;/p&gt;
&lt;p&gt;“It works on my machine!” Seguramente todo desarrollaror/a haya usado esta
frase en algún momento de su carrera para justificar la presencia de un bug.
Decir esto implica, más allá del bug en cuestión, que hay una diferencia no muy
evidente (pero sí perjudicial) entre los entornos de desarrollo y el
productivo.&lt;/p&gt;
&lt;p&gt;En los últimos años se trató de minimizar estas diferencias por medio de
entornos reproducibles. Las herramientas de cloud computing, infrastructure as
code y principalmente el uso de containers facilitaron esto. Sin embargo, estas
herramientas no siempre garantizan que lo que hagamos sea reproducible. Además,
en varios casos su complejidad de uso hace que se usen solamente en entornos de
staging y no en las máquinas de los desarrolladores, lo que nos vuelve a llevar
al “it works on my machine”.&lt;/p&gt;
&lt;p&gt;Voy a hablar de Nix, un lenguaje de programación, package manager y build tool
que tiene a la reproducibilidad como idea principal. Nix permite construir un
entorno reproducible sin tener el overhead que traen el uso de containers o VMs
(aunque también se lleva muy bien con estos). De esta forma, resulta muy
conveniente tanto al momento de desarrollar como al servir el software en
producción.&lt;/p&gt;&lt;/div&gt;</description><category>conferencia</category><category>docker</category><category>nix</category><category>sysadmin</category><guid>https://licenciaparahackear.github.io/posts/invitacion-a-nerdearla/</guid><pubDate>Thu, 10 Oct 2019 01:37:28 GMT</pubDate></item><item><title>Bypasseando una sandbox de JS restrictiva</title><link>https://licenciaparahackear.github.io/posts/bypasseando-una-sandbox-de-js-restrictiva/</link><dc:creator>Matías Lang</dc:creator><description>&lt;div&gt;&lt;p&gt;Participando en un programa de bug bounties encontré un sitio con una
funcionalidad bastante interesante que permitía filtrar un conjunto de datos
según una expresión controlada por el usuario. Es decir, podía ponerle algo
como &lt;code&gt;book.price &amp;gt; 100&lt;/code&gt; para que solamente me muestre los libros que salgan más
que $100. Usando &lt;code&gt;true&lt;/code&gt; y &lt;code&gt;false&lt;/code&gt; como filtros me mostraba todos y ningún
resultado, respectivamente. Por lo que podía saber si el resultado de la
expresión que le pasé se evaluaba a verdadero o falso.&lt;/p&gt;
&lt;p&gt;Como la funcionalidad me llamó la atención seguí probando con expresiones más
complejas como &lt;code&gt;(1+1).toString()==="2"&lt;/code&gt; (verdadero) y &lt;code&gt;(1+1).toString()==="5"&lt;/code&gt;
(falso). Esto es claramente código JavaScript, así que supuse que la expresión
se le pasaba a una función similar a &lt;code&gt;eval&lt;/code&gt; en un server corriendo NodeJS, por
lo que parecía que estaba cerca de encontrar un RCE (remote code execution).
Sin embargo, cuando probaba poner expresiones un poco más complejas el sistema
me tiraba un error diciendo que la expresión era inválida. Asumí que lo que le
mandaba pasaba por algún sistema de sandbox para JavaScript.&lt;/p&gt;
&lt;p&gt;Los sistemas de sandbox que se usan para ejecutar código ajeno en un entorno
restringido suelen ser muy difíciles de implementar, y generalmente existen
maneras de bypassear estas protecciones para así ejecutar nuestro código con
privilegios normales. Esto es especialmente cierto si se trata de limitar el
uso de lenguajes complejos, llenos de funcionalidades ocultas como es el caso
de JavaScript. Como el problema ya había logrado tomar mi atención decidí
dedicarle un tiempo importante a tratar de romper esta sandbox para aprender un
poco del funcionamiento interno de JavaScript, y de paso ganar algunos dólares
en caso de encontrar un RCE.&lt;/p&gt;
&lt;p&gt;Lo primero que hice fue identificar qué librería usaban para implementar la
sandbox, dado que el ecosistema de NodeJS se caracteriza por tener decenas de
librerías que hacen exactamente lo mismo, y en muchos casos todas lo hacen mal.
También se podía tratar de una solución implementada por el mismo sitio y no
por una librería, pero como es algo muy complejo me pareció muy difícil que se
hayan tomado el trabajo de desarrollar algo así, por lo que descarté esta
posibilidad inmediatamente.&lt;/p&gt;
&lt;p&gt;Finalmente, analizando los mensajes de error de la aplicación llegué a la
conclusión de que estaban utilizando &lt;a href="https://github.com/substack/static-eval"&gt;static-eval&lt;/a&gt;, una librería
no muy conocida (aunque escrita por &lt;a href="https://twitter.com/substack"&gt;substack&lt;/a&gt;, alguien bastante
conocido dentro de la comunidad de NodeJS). Si bien no fue hecha con el
propósito de ser usada como una sandbox para ejecutar código desconocido (debo
reconocer que todavía no entendí para qué fue hecha), su documentación da a
entender esto. En el caso del sitio que estaba auditando, sí se usaba esta
librería como una sandbox.&lt;/p&gt;
&lt;h3&gt;Rompiendo static-eval&lt;/h3&gt;
&lt;p&gt;La idea de static-eval consiste en utilizar la librería &lt;a href="https://github.com/jquery/esprima/"&gt;esprima&lt;/a&gt; para
parsear la sintaxis del código JS que le mandemos y generar así un &lt;a href="https://es.wikipedia.org/wiki/%C3%81rbol_de_sintaxis_abstracta"&gt;AST
(Abstract Syntax Tree)&lt;/a&gt; de nuestra expresión. Una vez hecho esto, dado el
AST generado y un objeto con las variables que se quiere que estén disponibles,
se trata de evaluar la expresión. En caso de encontrar algo un poco fuera de lo
común, la función falla y el código no es evaluado. Al principio esto me
desmotivó un poco porque me di cuenta de que el sandbox era muy restrictivo con
el código que se le pasaba. Ni siquiera me permitía poner un &lt;code&gt;for&lt;/code&gt; o un &lt;code&gt;while&lt;/code&gt;
dentro de la expresión por lo que hacer algo que requiera un algoritmo
iterativo se hacía casi imposible. De todas formas, seguí tratando de
encontrarle algo.&lt;/p&gt;
&lt;p&gt;Sin encontrar ningún bug a simple vista, me puse a ver los commits y
pull requests del &lt;a href="https://github.com/substack/static-eval"&gt;proyecto en GitHub&lt;/a&gt;. En particular,
el &lt;a href="https://github.com/substack/static-eval/pull/18"&gt;pull request #18&lt;/a&gt; arregló dos bugs que permitían
escaparse de la sandbox, exactamente lo que estaba tratando de encontrar.
También encontré un &lt;a href="https://maustin.net/articles/2017-10/static_eval"&gt;blogpost del autor del pull request&lt;/a&gt; que
explicaba con más detalle estas vulnerabilidades. Lo primero que hice fue
probar estas técnicas en la aplicación que estaba testeando, pero
desafortunadamente para mí, la versión de static-eval que utilizaban ya había
corregido estos fallos. Sin embargo, saber que alguien más ya había roto la
librería me dio más confianza así que seguí buscando otra forma de explotarla.&lt;/p&gt;
&lt;p&gt;A continuación, me puse a analizar más profundamente las vulnerabilidades
ya encontradas para ver si me podía inspirar en alguna para encontrar algo
nuevo. &lt;/p&gt;
&lt;h3&gt;Análisis de la primera vulnerabilidad&lt;/h3&gt;
&lt;p&gt;Una de las vulnerabilidades encontradas consistía en hacer uso del &lt;a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/Function"&gt;function
constructor&lt;/a&gt;. Esta técnica es utilizada frecuentemente para
bypassear sandboxes. Por ejemplo, varias de las &lt;a href="https://portswigger.net/blog/xss-without-html-client-side-template-injection-with-angularjs"&gt;formas de bypassear la sandbox
de angular.js para lograr un XSS&lt;/a&gt; usan distintas
variaciones que terminan accediendo y llamando al function constructor.
También fue usado para &lt;a href="https://github.com/patriksimek/vm2/issues/32"&gt;bypassear librerías similares a static-eval, como
vm2&lt;/a&gt;. La siguiente expresión demuestra la existencia de la
vulnerabilidad accediendo a las variables de entorno del sistema (algo que
debería estar restringido ya que el código se ejecuta en una sandbox):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;constructor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"console.log(process.env)"&lt;/span&gt;&lt;span class="p"&gt;)()&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;En este código, &lt;code&gt;"".sub&lt;/code&gt; es una forma corta de obtener una función (también hubiese
servido algo como &lt;code&gt;(function(){})&lt;/code&gt;). Luego se accede a su constructor, que es una
función que crea nuevas funciones con el código que se le pase como argumento.
Esto vendría a ser como una función eval, solo que en vez de evaluar la expresión
inmediatamente, retorna una función que ejecutará el código recién cuando sea
llamada. Esto explica los paréntesis que están al final del payload, que hacen
que se llame a la función creada.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Resultado de ejecutar el payload anterior" src="https://licenciaparahackear.github.io/images/static-eval/constructor-bypass.png" title="Resultado de ejecutar el payload anterior"&gt;&lt;/p&gt;
&lt;p&gt;No solo es posible mostrar las variables de entorno, sino que también se
pueden ejecutar comandos en el sistema, usando la función execSync del módulo
child_process de NodeJS. El siguiente payload va a retornar la salida del
comando &lt;code&gt;id&lt;/code&gt; del sistema:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;constructor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"console.log(global.process.mainModule.constructor._load(\"child_process\").execSync(\"id\").toString())"&lt;/span&gt;&lt;span class="p"&gt;)()&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;El código es similar al anterior, excepto por el cuerpo de la función que se
crea.  En este caso, &lt;code&gt;global.process.mainModule.constructor._load&lt;/code&gt; viene a ser
lo mismo que la función &lt;code&gt;require&lt;/code&gt; de NodeJS que se usa para cargar módulos. Por
alguna razón que no entendí, esta función no está disponible bajo el nombre
&lt;code&gt;require&lt;/code&gt; dentro del function constructor.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Resultado de ejecutar el payload que ejecuta el comando id" src="https://licenciaparahackear.github.io/images/static-eval/constructor-execsync.png" title="Resultado de ejecutar el payload que ejecuta el comando id"&gt;&lt;/p&gt;
&lt;p&gt;El fix para esta vulnerabilidad consistió en bloquear el acceso a propiedades
de objetos que sean una función (para esto está el &lt;code&gt;typeof obj == 'function'&lt;/code&gt;):&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="s1"&gt;'MemberExpression'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;walk&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;object&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// do not allow access to methods on Function &lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nx"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="nx"&gt;FAIL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;typeof&lt;/span&gt; &lt;span class="nx"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'function'&lt;/span&gt;&lt;span class="p"&gt;)){&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;FAIL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Esto es algo bastante sencillo, pero sorprendentemente efectivo. El function
constructor está disponible, naturalmente, solamente en funciones, así que no
es posible acceder a este. Además el &lt;code&gt;typeof&lt;/code&gt; de un objeto no se puede
modificar, por lo que cualquier cosa que sea una función va a tener su typeof
fijo a &lt;code&gt;function&lt;/code&gt;. No encontré ninguna forma de bypassear esta protección así
que seguí con la siguiente vulnerabilidad que habían encontrado.&lt;/p&gt;
&lt;h3&gt;Análisis de la segunda vulnerabilidad&lt;/h3&gt;
&lt;p&gt;Esta vulnerabilidad, a diferencia de la primera, es bastante más sencilla: el
problema era que la sandbox permitía que se creen funciones anónimas, pero no
chequeaba que el código de estas funciones no tenga nada malicioso, sino que se
lo pasaba directamente al function constructor. El siguiente código tiene el
mismo efecto que el primer payload que se utilizó en este blogpost:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;process&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;env&lt;/span&gt;&lt;span class="p"&gt;)})()&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;También se puede cambiar el cuerpo de la función para que use el &lt;code&gt;execSync&lt;/code&gt;
y muestre la salida de ejecutar un comando. Voy a dejar esto como ejercicio
para el/la lector/a.&lt;/p&gt;
&lt;p&gt;Un posible fix para esto hubiese sido prohibir la declaración de funciones
anónimas dentro de las expresiones. Sin embargo esto hubiese hecho imposible
el uso benigno de las funciones anónimas (como por ejemplo, hacer un map
a un array). Se tuvo que hacer un fix que permita el uso de funciones
anónimas "benignas" pero bloquee las maliciosas. Para esto, static-eval
analiza el cuerpo de la función al momento de su definición para
detectar que no se hagan cosas malas, como acceder al constructor de
una función.&lt;/p&gt;
&lt;p&gt;Este fix resultó ser mucho más complejo que el de la primera vulnerabilidad,
y además Matt Austin (el autor del fix) hizo entender que no estaba seguro
de que esto funcione perfectamente. Así que me incliné por buscar un bypass
a este fix.&lt;/p&gt;
&lt;h3&gt;Encontrando una nueva vulnerabilidad&lt;/h3&gt;
&lt;p&gt;Una cosa que me hacía bastante ruido es que se decidía si la función era buena
o mala solamente al momento de definirla, y no al momento de llamarla.  Es
decir, que no se tenía en cuenta el valor de los argumentos de la función, ya
que esto requeriría que se haga un chequeo al momento de llamar a la función.&lt;/p&gt;
&lt;p&gt;Mi idea siempre fue tratar de acceder, de alguna forma, al function constructor
para que me deje crear cualquier función libremente, esquivando el fix de la
primera vulnerabilidad que me lo impedía ya que no me dejaba acceder a
propiedades de una función. Sin embargo, ¿qué pasaría si trato de acceder
constructor de un parámetro de la función? como su valor no es conocido al
momento de definir la función, quizás esto pueda confundir al sistema y hacer
que nos la deje pasar. Para probar mi teoría usé esta expresión:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;algo&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;algo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;constructor&lt;/span&gt;&lt;span class="p"&gt;})(&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Si esto retornara el constructor de una función ya tendría un bypass efectivo.
Lamentablemente no fue el caso, ya que static-eval bloquea la función si se
accede a una propiedad de algo cuyo tipo es desconocido al momento de
definición de la función (en este caso, el argumento &lt;code&gt;algo&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Un feature de static-eval que seguramente utilicen prácticamente todas las
aplicaciones que usan la librería es que se pueden pasar algunas variables que
se desea que estén disponibles dentro de la expresión. Por ejemplo, al
principio del post usé la expresión &lt;code&gt;book.price &amp;gt; 100&lt;/code&gt;. En este caso, el código
que llama a static-eval le estaría pasando el valor de la variable &lt;code&gt;book&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Esto me produjo otra idea: ¿y si una función toma un argumento con el nombre de
una variable ya definida? como no puede conocer el valor real del argumento,
quizás use el valor inicial de la variable. Esto sería muy útil para mí.
Supongamos que existe una variable &lt;code&gt;book&lt;/code&gt; que es un objeto. Entonces la siguiente
expresión:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;book&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;book&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;constructor&lt;/span&gt;&lt;span class="p"&gt;})(&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;tendría un resultado muy satisfactorio: al momento de definir la función se
chequearía si &lt;code&gt;book.constructor&lt;/code&gt; es una expresión válida. Como &lt;code&gt;book&lt;/code&gt; es
inicialmente un objeto (cuyo typeof es &lt;code&gt;object&lt;/code&gt;) y no una función, esto
se consideraría una expresión válida y la función sería creada. Al
momento de llamar a esta función, sin embargo, &lt;code&gt;book&lt;/code&gt; sí será una función
y entonces retornará el function constructor.&lt;/p&gt;
&lt;p&gt;Lamentablemente, esto tampoco funcionó ya que el autor del fix consideró
este caso. Al momento analizar el cuerpo de una función, el valor
de todos los argumentos se fija en &lt;code&gt;null&lt;/code&gt;, sobreescribiendo el valor de
las variables iniciales. Este es un fragmento del código que hace eso:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;params&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;forEach&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s1"&gt;'Identifier'&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
      &lt;span class="nx"&gt;vars&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;key&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Este código toma el nodo del AST que define la función, itera por cada uno de
sus parámetros cuyo tipo sea &lt;code&gt;Identifier&lt;/code&gt;, obtiene su nombre y setea a null el
atributo de &lt;code&gt;vars&lt;/code&gt; con ese nombre. Si bien el código parece correcto, tiene una
falla bastante común al programar, que es que no está contemplando todos los
casos posibles. ¿qué pasa si &lt;code&gt;key.type&lt;/code&gt; es algo raro y tiene un valor diferente
de &lt;code&gt;Identifier&lt;/code&gt;?  en vez de hacer algo prudente como decir &lt;em&gt;"no sé qué es esto
así que mejor voy a bloquear a la función"&lt;/em&gt; (como si fuera una whitelist),
ignora el parámetro y sigue con los demás (como en una blacklist). Esto
significa que si logro que el nodo que representa a un argumento de mi función
tenga un type distinto de &lt;code&gt;Identifier&lt;/code&gt;, el valor de la variable no se pisaría,
por lo que seguiría con el valor inicial.  Acá empecé a tener seguridad de que
encontré algo importante.  Solamente me faltaba ver como poner el &lt;code&gt;key.type&lt;/code&gt; a
algo diferente.&lt;/p&gt;
&lt;p&gt;Como comenté anteriormente, static-eval usa &lt;a href="https://github.com/jquery/esprima/"&gt;la librería esprima&lt;/a&gt; para
parsear el código de la expresión que le pasemos. Según indica su página,
esprima es un parser que soporta correctamente el estándar &lt;a href="https://www.ecma-international.org/ecma-262/7.0/"&gt;ECMAScript
2016&lt;/a&gt;. ECMAScript viene a ser algo así como un dialecto de JavaScript con
más features, que hace que su sintaxis sea más cómoda&lt;sup id="fnref-ecma-disclaimer"&gt;&lt;a class="footnote-ref" href="https://licenciaparahackear.github.io/posts/bypasseando-una-sandbox-de-js-restrictiva/#fn-ecma-disclaimer"&gt;1&lt;/a&gt;&lt;/sup&gt;. &lt;/p&gt;
&lt;p&gt;Un feature que se agregó a ECMAScript es el de &lt;a href="https://simonsmith.io/destructuring-objects-as-function-parameters-in-es6/"&gt;function parameter
destructuring&lt;/a&gt;. Con este feature, el siguiente código ECMAScript
ahora es válido:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;nombreCompleto&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="nx"&gt;nombre&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;apellido&lt;/span&gt;&lt;span class="p"&gt;}){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;nombre&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;" "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;apellido&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;nombreCompleto&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="nx"&gt;nombre&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"John"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;apellido&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"McCarthy"&lt;/span&gt;&lt;span class="p"&gt;}))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Las llaves adentro de los parámetros de la función indican que la función no
toma dos argumentos &lt;code&gt;nombre&lt;/code&gt; y &lt;code&gt;apellido&lt;/code&gt;, sino solo uno que es un objeto
que debe tener las propiedades &lt;code&gt;nombre&lt;/code&gt; y &lt;code&gt;apellido&lt;/code&gt;. El código anterior es
equivalente a esto:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;nombreCompleto&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;individuo&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;individuo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;nombre&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;" "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;individuo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;apellido&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;nombreCompleto&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="nx"&gt;nombre&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"John"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;apellido&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;"McCarthy"&lt;/span&gt;&lt;span class="p"&gt;}))&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Si vemos el AST que genera esprima (yo lo hice usando &lt;a href="http://esprima.org/demo/parse.html"&gt;esta
página&lt;/a&gt;), nos vamos a llevar una agradable sorpresa
(quizás no tan sorprendente):&lt;/p&gt;
&lt;p&gt;&lt;img alt="Resultado de parsear la función que usa parameter destructuring" src="https://licenciaparahackear.github.io/images/static-eval/esprima-online-parser.png"&gt;&lt;/p&gt;
&lt;p&gt;Efectivamente, esta nueva sintaxis hace que el argumento tenga un type distinto
a &lt;code&gt;Identifier&lt;/code&gt;, por lo que static-eval no lo va a tener en cuenta a la hora
de sobrescribir las variables. De esta forma, al evaluar&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="nx"&gt;book&lt;/span&gt;&lt;span class="p"&gt;}){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;book&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;constructor&lt;/span&gt;&lt;span class="p"&gt;})({&lt;/span&gt;&lt;span class="nx"&gt;book&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;static-eval usa el valor inicial de book, que es un objeto. Entonces autoriza
la creación de la función, aunque cuando esta se llama, book pasa a ser una
función y retorna su constructor. Ya tengo el bypass!&lt;/p&gt;
&lt;p&gt;La expresión anterior devuelve el function constructor, así que solo
falta llamarlo para crear una función maliciosa, y después llamar a la
función creada:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="nx"&gt;book&lt;/span&gt;&lt;span class="p"&gt;}){&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;book&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;constructor&lt;/span&gt;&lt;span class="p"&gt;})({&lt;/span&gt;&lt;span class="nx"&gt;book&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s2"&gt;""&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;})(&lt;/span&gt;&lt;span class="s2"&gt;"console.log(global.process.mainModule.constructor._load(\"child_process\").execSync(\"id\").toString())"&lt;/span&gt;&lt;span class="p"&gt;)()&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Probé ejecutar esta expresión localmente con la versión fixeada de static-eval,
y obtuve lo que estaba esperando:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Exploit final funcionando" src="https://licenciaparahackear.github.io/images/static-eval/exploit-final.png"&gt;&lt;/p&gt;
&lt;p&gt;Efectivamente, encontré un bypass a la librería static-eval que me permitió
conseguir ejecución de comandos en la máquina que lo ejecute. La única
condición requerida es conocer el nombre de una variable definida cuyo valor no
sea una función, y que tenga una propiedad &lt;code&gt;constructor&lt;/code&gt;. Tanto strings,
números, arrays y objetos cumplen esta propiedad, por lo debería ser fácil
lograr que se cumpla esta condición. Solamente me faltaba usar esta técnica en
el sitio que estaba testeando, lograr una PoC del RCE y reclamar mi dinero,
bastante sencillo. ¿o quizás no?&lt;/p&gt;
&lt;h2&gt;Descubriendo que el exploit no servía en mi target&lt;/h2&gt;
&lt;p&gt;Desgraciadamente, no. Después de haber hecho todo este trabajo y encontrar un
bypass elegante y funcional, me di cuenta de que este no iba a servir en el
sitio que estaba testeando. La única condición que el exploit requería era que
se tenga el nombre de una variable cuyo valor no sea una función, por lo que
resulta lógico asumir que no pude obtener esto y así hacer funcionar mi
técnica. Sin embargo, la razón por la que no funcionó es todavía más ridícula.&lt;/p&gt;
&lt;p&gt;Para dar un poco de contexto, el sitio no usaba static-eval directamente, sino
que lo hacía a través de la librería de npm &lt;a href="https://github.com/dchester/jsonpath"&gt;jsonpath&lt;/a&gt;.  JSONPath
es un query language con un propósito similar a XPATH, pero para documentos
JSON. Fue publicado inicialmente en 2007 en &lt;a href="https://goessner.net/articles/JsonPath/"&gt;este artículo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Tras familiarizarme con JSONPath me di cuenta de que se trata de un proyecto
bastante pobre, sin una especificación clara acerca de cómo debería funcionar.
La mayoría de las features que implementa parecen haberse desarrollado de forma
improvisada, sin pensar si se estaba tomando una buena decisión al incluirlas.
Es una lástima que el ecosistema de NodeJS esté lleno de librerías como esta.&lt;/p&gt;
&lt;!--
Dejemos esto para quien se moleste en leer el source code del post

Personalmente, me da vergüenza que existan este tipo de cosas tan atadas con
alambre y con una especificación tan pobre. El mismo autor de la librería
señaló que prácticamente tuvo que hacerle ingeniería inversa al código original
para entender lo que hacía. El hecho de que JSONPath sea tan utilizado refleja
lo limitado que es el ecosistema de NodeJS.
--&gt;

&lt;p&gt;&lt;img alt="" src="https://licenciaparahackear.github.io/images/static-eval/npm-install.jpeg"&gt;&lt;/p&gt;
&lt;p&gt;JSONPath tiene un feature al que llama filter expressions, que permite filtrar
documentos que cumplan una cierta expresión. Un ejemplo es
&lt;code&gt;$.store.book[?(@.price &amp;lt; 10)].title&lt;/code&gt;, que busca los libros que salgan menos de
$10, y retorna el título de cada uno de ellos. En el caso de la librería que
mencioné anteriormente, la expresión entre paréntesis se evalúa utilizando
static-eval. El sitio permitía que le pase una expresión de JSONPath que
parseaba con esa misma librería, por lo que el RCE era ya evidente.&lt;/p&gt;
&lt;p&gt;Si nos ponemos a ver detalladamente el JSONPath anterior, vemos que la
expresión que se le pasa a static-eval es &lt;code&gt;@.price &amp;lt; 10&lt;/code&gt;. Según la
documentación, &lt;code&gt;@&lt;/code&gt; es una variable que contiene información del documento
(generalmente es un objeto, por lo que cumple la condición que necesita mi
técnica para funcionar). Desgraciadamente, al autor de JSONPath path se le
ocurrió llamarle &lt;code&gt;@&lt;/code&gt; a esta variable. Y resulta que según la especificación de
ECMAScript, &lt;code&gt;@&lt;/code&gt; no es un nombre de variable válido. Es más, para que la
librería funcione correctamente, tuvieron que hacer una cosa horrible que es
&lt;a href="https://github.com/dchester/jsonpath/blob/87f97be392870c469308dd4dc90d2067863ea02a/lib/aesprim.js#L8"&gt;parchear el código de esprima para que acepte &lt;code&gt;@&lt;/code&gt; como nombre de
variable&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Cuando se crea una función anónima en static-eval, esta se mete adentro de otra
función que toma como argumentos las variables inicialmente definidas. Es
decir, que si creo funciones anónimas dentro de un filter expression de
JSONPath, se va a crear una función que toma como argumento una variable &lt;code&gt;@&lt;/code&gt;.
Esto se hace directamente llamando al function constructor, sin tener en cuenta
el parche que le hicieron a esprima, por lo que crear esa función tira un error
que no puedo evitar. Esto es &lt;strong&gt;un bug en la librería&lt;/strong&gt;, que hace que no pueda
usar funciones dentro de filter expressions (ni benignas ni maliciosas). Y por
culpa de esto, mi forma de bypassear el sandbox no funciona en este contexto.&lt;/p&gt;
&lt;p&gt;Solamente por culpa de la pésima decisión de llamar &lt;code&gt;@&lt;/code&gt; a una variable en una
librería utilizada principalmente en JS, donde &lt;code&gt;@&lt;/code&gt; no es un nombre de variable
válido en JS, no fui capaz de encontrar un RCE en el sitio y obtener una
recompensa importante, que seguramente no hubiese bajado de las cuatro cifras.
Por qué no la habrá llamado &lt;code&gt;_&lt;/code&gt; (que sí es un nombre válido), &lt;code&gt;document&lt;/code&gt; o
&lt;code&gt;pepito&lt;/code&gt;!!!  Esta vez me tendré que conformar solamente con haber descubierto
una vulnerabilidad en la librería y haber aprendido un montón sobre JavaScript.&lt;/p&gt;
&lt;h2&gt;Conclusiones&lt;/h2&gt;
&lt;p&gt;Si bien no pude obtener el bounty que estaba esperando, pasé un buen rato
jugando con esta librería, y lo que aprendí lo pude utilizar para bypassear
otro tipo entornos de JS restringidos y obtener una recompensa económica.
Próximamente espero poder publicar también esta otra investigación.&lt;/p&gt;
&lt;p&gt;Quiero mencionar una vez más &lt;a href="https://maustin.net/articles/2017-10/static_eval"&gt;el excelente trabajo previo hecho por Matt Austin
acerca de static-eval&lt;/a&gt;. Sin este material quizás no hubiese
encontrado esta nueva vulnerabilidad.&lt;/p&gt;
&lt;p&gt;Como recomendación general a la hora de testear un sistema, siempre suena
interesante tratar de replicar y aislar un feature de este en un entorno local
que podamos controlar totalmente. En mi caso, me armé una instancia de Docker
con la librería static-eval para probar bypassear el sandbox.  Mi problema fue
que me quedé exclusivamente jugando con esta instancia en vez de probar lo que
iba descubriendo en el sitio real. Si hubiese hecho esto antes, quizás me
habría dado cuenta de que lo que estaba haciendo no iba a funcionar en el sitio
y me hubiese movido a otra cosa. La lección aprendida es que no hay que
abstraerse tanto sobre un sistema, y que no hay que probar lo que encontré en
este sistema recién al final.&lt;/p&gt;
&lt;p&gt;Finalmente, si están auditando un sitio que tenga un sistema similar para
evaluar expresiones dentro de una sandbox, definitivamente recomiendo que se
queden algún rato largo tratando de romperlo. Sería muy raro encontrar un
sistema de sandbox que no tenga vulnerabilidades, especialmente si se trata de
lenguajes dinámicos y llenos de features como pueden ser JavaScript, Python o
Ruby. Y cuando estas vulnerabilidades son explotadas, generalmente tienen
un impacto crítico en la aplicación que las contenga.&lt;/p&gt;
&lt;p&gt;Espero que el post les haya resultado útil. Saludos!&lt;/p&gt;
&lt;h2&gt;Extra: Cronología del bug&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;02/01/19 - Informe del bug enviado al equipo de seguridad de NodeJS y al desarrollador
de static-eval. Se puede leer el informe original &lt;a href="https://licenciaparahackear.github.io/posts/static-eval-sandbox-escape-original-writeup/"&gt;acá&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;03/01/19 - El equipo de seguridad de NodeJS replica el bug. Me dijeron que iban a
contactar al desarrollador de static-eval y publicar un advisory dentro de 45 días
en caso de que no haya una respuesta&lt;/li&gt;
&lt;li&gt;14/02/19 - &lt;a href="https://www.npmjs.com/advisories/758"&gt;Advisory publicado en el sitio de npmjs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;15/02/19 - &lt;a href="https://github.com/browserify/static-eval/pull/21"&gt;Se fixeó la librería&lt;/a&gt; y se releaseó una nueva versión con
  este cambio&lt;/li&gt;
&lt;li&gt;18/02/19 - Se modificó el fichero README de la libraría para &lt;a href="https://github.com/browserify/static-eval/pull/22/files"&gt;indicar explícitamente
  que la librería no debe ser utilizada como una sandbox&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;26/02/19 - Se aplicó &lt;a href="https://github.com/browserify/static-eval/pull/23"&gt;un nuevo fix&lt;/a&gt; a la librería, ya que el fix que hice
  antes resultó tener un bug que hacía que siga siendo vulnerable&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="footnote"&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id="fn-ecma-disclaimer"&gt;
&lt;p&gt;Cabe aclarar que esto es una definición bastante vaga
y probablemente incorrecta sobre lo que es ECMAScript en realidad. Es simplemente
lo que yo siento que es. Mi indiferencia hacia el ecosistema de JavaScript hace
que ni me moleste en buscar una definición más precisa. &lt;a class="footnote-backref" href="https://licenciaparahackear.github.io/posts/bypasseando-una-sandbox-de-js-restrictiva/#fnref-ecma-disclaimer" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>bug bounty</category><category>bypass</category><category>javascript</category><category>jsonpath</category><category>nodejs</category><category>remote code execution</category><category>sandbox</category><guid>https://licenciaparahackear.github.io/posts/bypasseando-una-sandbox-de-js-restrictiva/</guid><pubDate>Fri, 01 Mar 2019 15:01:15 GMT</pubDate></item><item><title>Licencia para Hackear está de vuelta!</title><link>https://licenciaparahackear.github.io/posts/licencia-para-hackear-esta-de-vuelta/</link><dc:creator>Matías Lang</dc:creator><description>&lt;div&gt;&lt;p&gt;Ya hace casi 4 años que no publico nada en mi blog. Un poco más si contamos
solamente artículos de mi autoría. Bastantes cosas camiaron desde ese momento,
en lo personal conseguí un trabajo bastante demandante y arranqué la facultad
por lo que mi tiempo libre se vio considerablemente reducido.&lt;/p&gt;
&lt;p&gt;Siempre estuve con ganas de retomar el blog en algún momento, aunque no sabía
cuando. Hace unos meses me di cuenta de que prácticamente todo el material
técnico que leía estaba escrito en inglés. Si bien ahora me llevo bastante bien
con ese idioma, no lo hacía cuando arranqué en el mundo de la seguridad
informática, y recuerdo lo complicado que era encontrar información de calidad
escrita en español. La mayoría de blogs en español que seguía también dejaron
de publicar cosas, o se convirtieron en simples propagandas de los productos de
Telefónica. Por esto me decidí a retomar el blog de una vez por todas, quizás
con contenido diferente al anterior pero manteniendo la idea de publicar
contenido técnico, en español y libre de empresas tratando de vender un
producto.&lt;/p&gt;
&lt;p&gt;La idea en esta nueva etapa es tratar de que todo lo que se publique esté
disponible en español. En caso de que sea alguna publicación importante también
puede haber una traducción al inglés. Al igual que en la primera etapa, el
contenido será principalmente sobre seguridad informática y programación. En
particular, ya tengo artículos pensados sobre vulnerabilidades en librerías de
NodeJS, soluciones a retos de CTFs y charlas de conferencias.&lt;/p&gt;
&lt;p&gt;Algo sobre lo que no tengo buenos recuerdos es tener que usar el editor de
Wordpress para redactar los artículos. Por esto voy a cambiar la plataforma que
uso por un generador de sitios estáticos. El nuevo material que publique va a
estar disponible en
&lt;a href="https://licenciaparahackear.github.io/"&gt;licenciaparahackear.github.io&lt;/a&gt;, no en
el blog viejo. El material viejo va a seguir disponible solamente en
&lt;a href="https://licenciaparahackear.wordpress.com/"&gt;licenciaparahackear.wordpress.com&lt;/a&gt;,
al menos hasta que encuentre la forma de exportar correctamente los posts de un
Wordpress a un sitio estático.&lt;/p&gt;
&lt;p&gt;Estén atentos, porque pronto se viene la primera publicación de esta nueva
etapa, y se viene con todo.&lt;/p&gt;
&lt;p&gt;Saludos!&lt;/p&gt;&lt;/div&gt;</description><guid>https://licenciaparahackear.github.io/posts/licencia-para-hackear-esta-de-vuelta/</guid><pubDate>Sun, 17 Feb 2019 06:48:50 GMT</pubDate></item></channel></rss>